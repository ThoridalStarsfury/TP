#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Dec  7 00:07:41 2020

@author: salihabdelaziz
"""

# This is a sample Python script.

# Press ⌃R to execute it or replace it with your code.
# Press Double ⇧ to search everywhere for classes, files, tool windows, actions, and settings.
import numpy as np
import os
from control.matlab import *
import matplotlib.pyplot as plt  # MATLAB plotting functions
from math import *
import math
from scipy import integrate
import scipy as sc
import control as crtl
from matplotlib.animation import FuncAnimation

# Use a breakpoint in the code line below to debug your script.
M = 3.2         # Masse du chariot
m = 0.329       # Masse du pendule
J = 0.072       # Iniertie du pendule
l = 0.44        # Longueur du pendule
g = 9.81
fr = 6.2        # Frottement fluide du chariot
fphi = 0.009      # Frottement fluide du pendule
Kf = 2.6        # Coefficient de force [N/V]
n1 = 14.9       # Capteur de position [V/m]
n2 = -52.27     # Capteur d'angle [V/rd]
n3 = -7.64      # Capteur de vitesse [V/m/s]
n4 = -52.27     # Capteur de vitesse angulaire [V/rd/s]
Ks= Kf*1.;        # Coefficient de friction in N
gs= -44.29  # Gain pour avoir un gain statique de la boucle fermée égal à 1
rd = 0.2  #le déplacement désiré du chariot


# définition des matrices d'état du système linéarisé
# définition de la matrice A
A1 = np.array([[0., 0., 1., 0.], [0., 0., 0., 1.]])
tmp1 = np.array([[M+m, m*l], [m*l, J+m*l*l]])
tmp2 = np.array([[0., 0., -fr, 0.], [0., m*g*l, 0., -fphi]])
A2 = np.linalg.inv(tmp1)@tmp2
A = np.block([[A1], [A2]])
print("A vaut\n", A)

# définition de la matrice B
B1 = np.array([[0.], [0.]])
tmp3 = np.array([[Kf], [0]])
B2 = np.linalg.inv(tmp1)@tmp3
B = np.block([[B1], [B2]])
print("\nB vaut\n", B)


# Définitionde la matrice C
C = np.array([[n1, 0, 0, 0], [0, n2, 0, 0], [0, 0, n3, 0]])
print("\nC vaut\n", C)

# Définition de la matrice D
D = np.array([[0], [0],[0]])
print("\nD vaut\n", D)

Te = 1e-3
Ad, Bd ,Cd , Dd, Te = sc.signal.cont2discrete((A, B, C, D), Te, "zoh")
print("\nAd vaut\n", Ad)
print("\nBd vaut\n", Bd)
print("\nCd vaut\n", Cd)
print("\nDd vaut\n", Dd)

    
# Définition du temps de simulation 
N = 10000

# définiton de la periode d'échantillonage
Te = 0.001


# définition du vecteur d'état initial de la fonction pendule_MNL x = [x1; x2; x3; x4]
x = np.zeros((4, 1))

# définition des matrices nécessaires pour mémoriser le vecteur d'état x dans la matrice xx
# et la dérivée du vecteur d'état x, nommée dx, dans la matrice dxx

dxx = np.zeros((4, N+1))
xx = np.zeros((4, N))       
yy = np.zeros((3, N))       # pour stokker la sortie
t = np.zeros(N)             # pour stocker le temps 

dxx[0, 0] = x[0, 0]
dxx[1, 0] = x[1, 0]
dxx[2, 0] = x[2, 0]
dxx[3, 0] = x[3, 0]
  
# initialisation du vecteur d'état estimé et de la commande
x_hat = np.zeros((5, 1))
u = 0.
xx_hat = np.zeros((5, N)) #pour stocker l'état estimé dans la matrice xx_hat

x_values = np.zeros(N)
y_values = np.zeros(N)


# Create a figure and axis
fig, ax = plt.subplots()
points, = ax.plot([], [], 'b')  # 'bo' means blue color, round markers

# Set the axis limits
ax.set_xlim(0, 0.8)
ax.set_ylim(-0.2, 0.2)


##############################################################################
#               A ne pas toucher
##############################################################################
def pendule_MNL(u, i):
    
    r       = x[0, 0]
    phi     = x[1, 0]
    dr      = x[2, 0]
    dphi    = x[3, 0]
    
    A1=np.array([[M+m, m*l*cos(phi)], [m*l*cos(phi), J+m*l*l]])
    
    f1 = -fr*dr + m*l*dphi*dphi*sin(phi) + Kf*u - Ks*np.sign(dr);
    f2 = m*g*l*sin(phi) - fphi*dphi;

    dxx1=np.array([[dr], [dphi]])
    dxx2=np.linalg.inv(A1)@np.array([[f1], [f2]])
    dx=np.block([[dxx1], [dxx2]])
    
    dxx[0, i+1]=dx[0]
    dxx[1, i+1]=dx[1]
    dxx[2, i+1]=dx[2]
    dxx[3, i+1]=dx[3]
    
    x[0, 0] = np.trapz([dxx[0, i], dxx[0, i+1]], dx=Te) + x[0, 0]
    x[1, 0] = np.trapz([dxx[1, i], dxx[1, i+1]], dx=Te) + x[1, 0]
    x[2, 0] = np.trapz([dxx[2, i], dxx[2, i+1]], dx=Te) + x[2, 0]
    x[3, 0] = np.trapz([dxx[3, i], dxx[3, i+1]], dx=Te) + x[3, 0]
    
    y = C@x
    
    return y

##############################################################################
#               A mettre ici votre observateur de Kalamn discret
##############################################################################
# Question 7 : 


def observateur(u, y, xhat) :
  
    Te = 1e-3
    
    # Te etant la periode d’echantillonageegale a 1 ms

    #Calcul des matrices d’etat discretes     
    xnext_hat = Acd@xhat+Bcd*u+Ld@(y-Ccd@xhat)
 
    return xnext_hat
   
# Update function for the animation
def update(frame):
    points.set_data(x_values[:frame], y_values[:frame])  # Update data for each frame
    return points,

# Press the green button in the gutter to run the script.
if __name__ == '__main__':  
    
    
    # Question 1 : Analyse de stabilité
    S1 = ss(A,B,C,D)
    print("\nla représentation d'état du système est\n", S1)
    H1 = ss2tf(S1) # la fonction de transfert de la représentation d'état S1
    Reso = crtl.pole(H1)
    
    print("\nles parties réelles des pôles de cette fonction de transfert sont\n",Reso)
    print("il est instable car il existe au moins une partie réelle des pôles de la fonction de transfert est positive\n")
    
    # Question 2 : Analyse de commandabilité du système linéairisé
    CoMatrice = ctrb(A, B) # matrice[ |B|AB|A²B|...|A^nB| ] il déjà connait la valeur de n(nombre d'état)
    determinant = np.linalg.det(CoMatrice) # vérifier le determinant non nul de la matrice dont la dimension est le plus grande possible 
    print("Ce système est commandable parce que le determinant de sa matrice commandable est\n", determinant)
    

    # Question 2 : Analyse d'observabilité
    CoMatrice2 = obsv(A,C)
    determinant2 = np.linalg.matrix_rank(CoMatrice2)#calcule le rang
    print("\nCe système est observable parce que le rang de sa matrice observable est\n", determinant2)
    
    # Question 3 
    # définition de la représentation d'état du système augmenté
    A1 = np.array([[0., 0., 1., 0., 0.], [0., 0., 0., 1., 0.]])
    tmp1 = np.array([[M+m, m*l], [m*l, J+m*l*l]])
    tmp2 = np.array([[0., 0., -fr, 0., -1], [0., m*g*l, 0., -fphi, 0.]])
    A2 = np.linalg.inv(tmp1)@tmp2
    A = np.block([[A1], [A2]])
    tmp1 = np.zeros((1,5))
    Acomplet = np.block([[A],[tmp1]])
    print("\nAcomplet vaut\n", Acomplet)
    Bcomplet = np.block([[B],[0]]) 
    print("\nBcomplet vaut\n", Bcomplet)
    tmp1 = np.zeros((3,1))
    Ccomplet = np.block([[C, tmp1]])
    print("\nCcomplet vaut\n", Ccomplet)
    
    S2 = ss(Acomplet,Bcomplet,Ccomplet,D)
    
    print("\nla représentation d'état du système augmenté est\n", S2)
    print("\nOn trouve que les représentations d'état des deux systèmes sont les mêmes")
    #Question 4
    # utiliser plutôt la fonction cont2discrete de scipy
    Te = 1e-3
    Acd, Bcd ,Ccd , Dcd, Te = sc.signal.cont2discrete((Acomplet, Bcomplet, Ccomplet, D), Te, "zoh")
    print("\nAd vaut\n", Acd)
    print("\nBd vaut\n", Bcd)
    print("\nCd vaut\n", Ccd)
    print("\nDd vaut\n", Dcd)
    
    # Question 5 : Calcul des poles de l'observateur de Kalamn discret
    p1c = -20; p2c = -19; p3c = -18; p4c = -17; p5c = -21
    p1d = math.exp(Te*p1c)
    p2d = math.exp(Te*p2c)
    p3d = math.exp(Te*p3c)
    p4d = math.exp(Te*p4c)
    p5d = math.exp(Te*p5c)
    print('\nLes pôles discrêtes sont\n', p1d,p2d,p3d,p4d,p5d)
    
    # Question 6 Calcul du gain de Kalman Ld
    pole = np.array([p1d,p2d,p3d,p4d,p5d])
    LdT = place(Acd.T,Ccd.T,pole)#pole est 1D array like
    Ld = LdT.T
    print("\nLe gain Ld vaut\n",Ld)
      
    
    # Question 8 : # placement des poles du retour d'état et calcul de K
    PSd = np.zeros(4)
    for i in range(0,4):
        PSc = np.array([-3,-4,-5,-6])
        PSd[i] = math.exp(PSc[i]*Te)
    print("\nles pôles PSd du retour d'état discret sont\n", PSd)
    
    K = place(Ad,Bd,PSd)
    print("\nla matrice K est\n",K)
    
    
    for i in range(0, N) :
        
        # Appel du système non linéaire
        y = pendule_MNL(u, i)

        # Question 7 : Appel de l'observateur
        x_hat = observateur(u,y,x_hat) 
        
        # Question 9 :  Calcul de la commande
        us = x_hat[4]/Kf
        ur = -K@x_hat[0:4,0] + gs*rd
        
        u = us[0, 0] + ur[0, 0] # donc "u" est un nombre flottant
    
        x_values[i] = x_hat[0, 0]+l*cos(x_hat[1,0])
        y_values[i] = l*sin(x_hat[1,0])
       

        ###################################################
        # Sauvegarde des données
        xx_hat[0, i]=x_hat[0]
        xx_hat[1, i]=x_hat[1]
        xx_hat[2, i]=x_hat[2]
        xx_hat[3, i]=x_hat[3]
        xx_hat[4, i]=x_hat[4]
        
        yy[0, i] = y[0]
        yy[1, i] = y[1]
        yy[2, i] = y[2]
        
        t[i]=Te*i
        
    # Create the animation
    animation = FuncAnimation(fig, update, frames=range(0, len(xx_hat[0, :]), 10), interval = 50, blit=True)

    # Save the animation as a video file (e.g., MP4)
    animation.save('point_animation.gif', writer='ffmpeg', fps=30)

    # Display the animation (optional)
    plt.figure()
    plt.show()    
    
    
    
    plt.figure(1)    
    plt.plot(t, yy[0, :])
    plt.xlabel('Time (s)')
    plt.ylabel('Amplitude(rad/s)')
    plt.legend(['y1(t)'])
    plt.title('position du chariot')
    plt.grid()
    
    plt.figure(2)    
    plt.plot(t, yy[1, :])
    plt.xlabel('Time (s)')
    plt.ylabel('Amplitude(rad/s)')
    plt.legend(['y2(t)'])
    plt.title('position angulaire du pendule')
    plt.grid()
    
    plt.figure(3)    
    plt.plot(t, yy[2, :])
    plt.xlabel('Time (s)')
    plt.ylabel('Amplitude(rad/s)')
    plt.legend(['y3(t)'])
    plt.title('vitesse de déplacement du chariot')
    plt.grid()
