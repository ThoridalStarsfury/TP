import numpy as np
import matplotlib.pyplot as plt
from math import *

def normalizeAngle(angle):
    while angle >= np.pi:
        angle -= 2.0 * np.pi
    while angle < -np.pi:
        angle += 2.0 * np.pi
    return angle 

def drawRobotMGD (th1, th2, color) :
     point1 = [0, 0]
     point2 = [a1*cos(th1), a1*sin(th1)]
     point3 = [a1*cos(th1)+a2*cos(th2+th1), a1*sin(th1)+a2*sin(th2+th1)]
     """point4 = [a1*cos(th1)+a2*cos(th2+th1)-0.04*sin(th1+th2), a1*sin(th1)+a2*sin(th2+th1)+0.04*cos(th1+th2)]
     point5 = [a1*cos(th1)+a2*cos(th2+th1)-0.04*sin(th1+th2)+0.02*cos(th2+th1), a1*sin(th1)+a2*sin(th2+th1)+0.04*cos(th1+th2)+0.02*sin(th2+th1)]
     point6 = [a1*cos(th1)+a2*cos(th2+th1)+0.04*sin(th1+th2), a1*sin(th1)+a2*sin(th2+th1)-0.04*cos(th1+th2)]
     point7 = [a1*cos(th1)+a2*cos(th2+th1)+0.04*sin(th1+th2)+0.02*cos(th2+th1), a1*sin(th1)+a2*sin(th2+th1)-0.04*cos(th1+th2)+0.02*sin(th2+th1)]
     x_values = [point1[0], point2[0], point3[0],point4[0],point5[0],point4[0],point6[0],point7[0]]
     y_values = [point1[1], point2[1], point3[1],point4[1],point5[1],point4[1],point6[1],point7[1]]"""
     x_values = [point1[0], point2[0], point3[0]]
     y_values = [point1[1], point2[1], point3[1]]
     plt.plot(x_values, y_values, color)
     plt.gca().axis('equal')
     plt.grid('on')
     
def calculateAndDrawRobotPose(w1,w2,th1Prev,th2Prev,col):
    th1Cur = normalizeAngle(th1Prev + w1*dT)
    th2Cur = normalizeAngle(th2Prev + w2*dT)    
    xCur =a1*cos(th1Cur)+a2*cos(th2Cur+th1Cur)
    yCur =a1*sin(th1Cur)+a2*sin(th2Cur+th1Cur)
    drawRobotMGD(th1Cur, th2Cur, 'r')
    plt.plot(xCur, yCur, marker='o', markersize=1, color=col)   
    return (xCur,yCur,th1Cur,th2Cur)
    
"""def fonction1(xPrev,yPrev):
    k = yd/xd
    p = np.arctan(yPrev/xPrev) ; pd = np.arctan(k)
    if p - pd > 1/360*2*np.pi:
        vdx = 0.4; vdy = 0
    elif p - pd < -1/360*2*np.pi:
        vdx = -0.4; vdy = 0
    elif xPrev > xd :
        vdx = -0.3; vdy = k*vdx
    else:
        vdx = 0.3; vdy = k*vdx
    return (vdx,vdy)"""


     
if __name__ =='__main__':
    N = 300
    a1 = 0.6 #robot size
    a2 = 0.4
    th = np.zeros(2)
    vd = np.zeros((2,1))
    w = np.zeros(2)
    x = np.zeros(N+1)
    y = np.zeros(N+1)
    xd = 0.7; yd = 0.3 
    th[0] = 1 #l'angle initiale de premier segment du robot
    th[1] = 1 #l'angle initiale de deuxi√®me segment du robot
    ini1 = th[0]; ini2 = th[1]
    x[0] = a1*cos(th[0])+a2*cos(th[1]+th[0])# la position initiale de la pince
    y[0] = a1*sin(th[0])+a2*sin(th[1]+th[0])
    vd[0] = 0.1; vd[1] = 0
    #vd[0],vd[1] = fonction1(x[0],y[0])
    J = np.array([[(-a1*sin(th[0])-a2*sin(th[0]+th[1])),-a2*sin(th[0]+th[1])],[(a1*cos(th[0])+a2*cos(th[0]+th[1])),(a2*cos(th[0]+th[1]))]])
    if np.linalg.det(J) == 0:
        w = np.linalg.pinv(J)@vd
    else:
        w = np.linalg.inv(J)@vd #la vitesse articulaire w initiale
    dT = 0.01 #seconds
    #loop
    for i in range(1,N+1):
         x[i],y[i],th[0],th[1] = calculateAndDrawRobotPose(w[0],w[1],th[0],th[1],'b')
         J =  np.array([[(-a1*sin(th[0])-a2*sin(th[0]+th[1])),-a2*sin(th[0]+th[1])],[(a1*cos(th[0])+a2*cos(th[0]+th[1])),(a2*cos(th[0]+th[1]))]])
         # J(qi)
         #vd[0],vd[1] = fonction1(x[0],y[0])
         if np.linalg.det(J) == 0:
             w = np.linalg.pinv(J)@vd
         else:
             w = np.linalg.inv(J)@vd #(w i+1)
    drawRobotMGD (ini1,ini2, 'k') # On trace la position du robot initiale
    drawRobotMGD (th[0], th[1], 'g')# On trace la position du robot finale
